C51 COMPILER V9.53.0.0   NRF24L01                                                          11/11/2024 11:51:25 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE NRF24L01
OBJECT MODULE PLACED IN .\Code\Obj\NRF24L01.obj
COMPILER INVOKED BY: D:\USR\Keil_v5\C51\BIN\C51.EXE Code\Source\NRF24L01.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib_nuvoton
                    -;.\Common;.\Code\Head;.\Code\Source;.\Code\Obj;.\LST;.\Output) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\NRF24L
                    -01.lst) TABS(2) OBJECT(.\Code\Obj\NRF24L01.obj)

line level    source

   1          //********************************************************************************************************
             -***
   2          //  NRF24L01 
   3          //********************************************************************************************************
             -***
   4          #include <GPIO.h>
   5          #include <SPI_prog.H>
   6          #include <NRF24L01.H>
*** WARNING C318 IN LINE 7 OF .\Code\Head\NRF24L01.H: can't open file 'COFIG.h'
   7          #include <N76E003.h>
   8          //**************************************************************************
   9          /*  MODE NRF    */
  10          //**************************************************************************
  11          
  12          bit modeRF = RX_MODE;  
  13          
  14          //**************************************************************************
  15          /*  struct for send mode RX     */
  16          //**************************************************************************
  17          xdata struct NRF_PACKET_SPI packetRX = {
  18            /*reg:            ,value:   */
  19            {W_REG|NRF_CONFIG ,0x0F},   //  CONFIG
  20            {W_REG|EN_AA      ,0x00},   //  EN_AA
  21            {W_REG|SETUP_AW   ,0x03},   //  SETUP_AW
  22            {W_REG|RF_CH      ,0x6E},   //  RF_CH   
  23            {W_REG|RF_SETUP   ,0x05},   //  RF_SETUP
  24            {W_REG|EN_RXADDR  ,0x1F},   //  EN_RXADDR   
  25            {W_REG|DYNPD      ,0x00},   //  DYNPD
  26            {W_REG|FEATURE    ,0x00},   //  FEATURE
  27            
  28            {W_REG|RX_PW_P0   ,0x01},   //  RX_PW_P0
  29            {W_REG|RX_PW_P1   ,0x01},   //  RX_PW_P0
  30            {W_REG|RX_PW_P2   ,0x01},   //  RX_PW_P0
  31            {W_REG|RX_PW_P3   ,0x01},   //  RX_PW_P0
  32            {W_REG|RX_PW_P4   ,0x01},   //  RX_PW_P0
  33            {W_REG|RX_PW_P5   ,0x01},   //  RX_PW_P0
  34            //adr write lsbyte first
  35            {W_REG|TX_ADDR    ,'X','X','X','X','X'},  //  TX_ADDR 
  36            
  37            {W_REG|RX_ADDR_P0 ,'X','X','X','X','X'},  //  RX_ADDR0
  38            {W_REG|RX_ADDR_P1 ,'V','V','V','V','V'},  //  RX_ADDR0
  39            {W_REG|RX_ADDR_P2 ,'q'},                  //  RX_ADDR0
  40            {W_REG|RX_ADDR_P3 ,'w'},                  //  RX_ADDR0
  41            {W_REG|RX_ADDR_P4 ,'e'},                  //  RX_ADDR0
  42            {W_REG|RX_ADDR_P5 ,'i'},                  //  RX_ADDR0
  43            
  44            {FLUSH_RX         ,NOP}     //  FLUSH   
  45          };
  46          //**************************************************************************
  47          /*  struct for send mode TX     */
  48          //**************************************************************************
  49          xdata struct NRF_PACKET_SPI packetTX = {
  50            /*reg:            ,value:   */
C51 COMPILER V9.53.0.0   NRF24L01                                                          11/11/2024 11:51:25 PAGE 2   

  51            {W_REG|NRF_CONFIG ,0x0E},   //  CONFIG
  52          };
  53          //**************************************************************************
  54          /*  struct for READ state reg   */
  55          //**************************************************************************
  56          xdata struct NRF_PACKET_SPI packetREAD = {
  57            /*reg:            ,value:   */
  58            {R_REG|NRF_CONFIG },    //  CONFIG
  59            {R_REG|EN_AA      },    //  EN_AA
  60            {R_REG|SETUP_AW   },    //  SETUP_AW
  61            {R_REG|RF_CH      },    //  RF_CH   
  62            {R_REG|RF_SETUP   },    //  RF_SETUP
  63            {R_REG|EN_RXADDR  },    //  EN_RXADDR   
  64            {R_REG|DYNPD      },    //  DYNPD
  65            {R_REG|FEATURE    },    //  FEATURE
  66            
  67            {R_REG|RX_PW_P0   },    //  RX_PW_P0
  68            {R_REG|RX_PW_P1   },    //  RX_PW_P0
  69            {R_REG|RX_PW_P2   },    //  RX_PW_P0
  70            {R_REG|RX_PW_P3   },    //  RX_PW_P0
  71            {R_REG|RX_PW_P4   },    //  RX_PW_P0
  72            {R_REG|RX_PW_P5   },    //  RX_PW_P0
  73            {R_REG|TX_ADDR    },    //  TX_ADDR 
  74            
  75            {R_REG|RX_ADDR_P0 },    //  RX_ADDR0
  76            {R_REG|RX_ADDR_P1 },    //  RX_ADDR0
  77            {R_REG|RX_ADDR_P2 },    //  RX_ADDR0
  78            {R_REG|RX_ADDR_P3 },    //  RX_ADDR0
  79            {R_REG|RX_ADDR_P4 },    //  RX_ADDR0
  80            {R_REG|RX_ADDR_P5 },    //  RX_ADDR0
  81            
  82            {FLUSH_RX         }     //  FLUSH   
  83          };
  84          
  85          //**************************************************************************
  86          /* ARRAY                        */
  87          //**************************************************************************
  88          xdata unsigned char COMMAND_STAT          [NRF_MASSIV_SIZE] = 
  89              {STATUS};
  90          xdata unsigned char COMMAND_SEND_RF       [NRF_MASSIV_SIZE] = 
  91              {W_TX_PL /*next byte for data send[1-x]*/};
  92          xdata unsigned char COMMAND_READ_RF       [NRF_MASSIV_SIZE] = 
  93              {R_RX_PL};
  94          xdata unsigned char COMMAND_CLEAR_FLUSH_RX[NRF_MASSIV_SIZE] = 
  95              {FLUSH_RX};
  96          xdata unsigned char COMMAND_CLEAR_FLUSH_TX[NRF_MASSIV_SIZE] = 
  97              {FLUSH_TX};
  98          xdata unsigned char COMMAND_CLEAR_IRQ     [NRF_MASSIV_SIZE] = 
  99              {W_REG|STATUS,0x70};
 100          xdata unsigned char COMMAND_READ_PIPE0    [NRF_MASSIV_SIZE] = 
 101              {RX_PW_P0};     
 102          xdata unsigned char COMMAND_READ_FIFO_STAT[NRF_MASSIV_SIZE] = 
 103              {FIFO_STATUS};    
 104          xdata unsigned char COMMAND_W_ACK_PAYLOAD [NRF_MASSIV_SIZE] = 
 105              {W_ACK_PL + /*need get(in status) ->PPP*/ 0x00};  
 106              
 107          //**************************************************************************
 108          /* NRF24L01 additional        */
 109          //**************************************************************************
 110          
 111          xdata unsigned char readBuf[NRF_MASSIV_SIZE]={0x00}; 
 112          
C51 COMPILER V9.53.0.0   NRF24L01                                                          11/11/2024 11:51:25 PAGE 3   

 113          bit FlagDataReadReady = 0;
 114          int currentProcess = 0;
 115              
 116          /*initialization RF(as RX)*/
 117          bit NRF_init(){
 118   1        switch(currentProcess){
 119   2          case START_PROCESS: NRF_CE = 0;                 break;
 120   2          
 121   2          case 1: NRF_delay(NRF_DELAY_MID);                 break;
 122   2          case 2: NRF_delay(NRF_DELAY_MID);                 break;
 123   2          case 3: Send_SPI_NRF( packetRX->vEN_AA,     2 );  break;
*** ERROR C200 IN LINE 123 OF Code\Source\NRF24L01.c: left side of '->' requires struct/union pointer
 124   2          case 4: Send_SPI_NRF( packetRX->vSETUP_AW,  2 );  break;  
 125   2          case 5: Send_SPI_NRF( packetRX->vRF_CH,     2 );  break;  
 126   2          case 6: Send_SPI_NRF( packetRX->vRF_SETUP,  2 );  break;  
 127   2          case 7: Send_SPI_NRF( packetRX->vEN_RXADDR, 2 );  break;
 128   2          case 8: Send_SPI_NRF( packetRX->vDYNPD,     2 );  break;  
 129   2          case 9: Send_SPI_NRF( packetRX->vFEATURE,   2 );  break;
 130   2          
 131   2          case 10:Send_SPI_NRF( packetRX->vTX_ADDR,   6 );  break;
 132   2      
 133   2          case 11:Send_SPI_NRF( packetRX->vRX_PW_P0,  2 );  break;
 134   2          case 12:Send_SPI_NRF( packetRX->vRX_PW_P1,  2 );  break;
 135   2          case 13:Send_SPI_NRF( packetRX->vRX_PW_P2,  2 );  break;
 136   2          case 14:Send_SPI_NRF( packetRX->vRX_PW_P3,  2 );  break;
 137   2          case 15:Send_SPI_NRF( packetRX->vRX_PW_P4,  2 );  break;
 138   2          case 16:Send_SPI_NRF( packetRX->vRX_PW_P5,  2 );  break;
 139   2          
 140   2          case 17:Send_SPI_NRF( packetRX->vRX_ADDR0,  6 );  break;
 141   2          case 18:Send_SPI_NRF( packetRX->vRX_ADDR1,  6 );  break;
 142   2          case 19:Send_SPI_NRF( packetRX->vRX_ADDR2,  2 );  break;
 143   2          case 20:Send_SPI_NRF( packetRX->vRX_ADDR3,  2 );  break;
 144   2          case 21:Send_SPI_NRF( packetRX->vRX_ADDR4,  2 );  break;
 145   2          case 22:Send_SPI_NRF( packetRX->vRX_ADDR5,  2 );  break;
 146   2          case 23: /*mode RF*/
 147   2            if(modeRF){
 148   3              Send_SPI_NRF( packetRX->vCONFIG,      2 );
 149   3            }
 150   2            else{
 151   3              Send_SPI_NRF( packetTX->vCONFIG,      2 );
 152   3            }
 153   2            break;
 154   2          
 155   2          case 24: NRF_delay(NRF_DELAY_MID);              break;
 156   2          case 25:  /*state CE in end init*/
 157   2            if(modeRF){
 158   3              NRF_CE = 1;
 159   3            }
 160   2            else{
 161   3              NRF_CE = 0;
 162   3            }
 163   2            break;
 164   2            
 165   2          case 26:currentProcess = END_PROCESS;           break;
 166   2          default: break;
 167   2        }
 168   1        return Check_Out();
 169   1      }
 170          
 171          /*NRF change mode to RX or TX */
 172          bit NRF_change_mode_RF(){
 173   1        switch(currentProcess){
C51 COMPILER V9.53.0.0   NRF24L01                                                          11/11/2024 11:51:25 PAGE 4   

 174   2          case START_PROCESS: NRF_CE = 0;                 break;
 175   2          case 1: NRF_delay(NRF_DELAY_MID);               break;
 176   2          case 2: /*mode RF*/
 177   2            if(modeRF){
 178   3              Send_SPI_NRF( packetRX->vCONFIG,      2 );
 179   3            }
 180   2            else{
 181   3              Send_SPI_NRF( packetTX->vCONFIG,      2 );
 182   3            }
 183   2            break;
 184   2            
 185   2          case 3: NRF_delay(NRF_DELAY_MID);               break;
 186   2          case 4: /*state CE in end init*/
 187   2            if(modeRF){
 188   3              NRF_CE = 1;
 189   3            }
 190   2            else{
 191   3              NRF_CE = 0;
 192   3            }
 193   2            break;
 194   2          
 195   2          case 5: currentProcess = END_PROCESS;           break;
 196   2          default: break;
 197   2        }
 198   1        return Check_Out();
 199   1      }
 200          
 201          /*NRF send(radio) */
 202          bit NRF_send(/*amount bytes*/){
 203   1        switch(currentProcess){
 204   2          case START_PROCESS: NRF_CE = 0;                             break;
 205   2          case 1: /*write something value*/;                          break;
 206   2          case 2: Send_SPI_NRF( &COMMAND_SEND_RF,/*amount bytes*/ 2 );break;
 207   2          case 3: NRF_CE = 1;                                         break;
 208   2          case 4: NRF_delay(NRF_DELAY_SHORT);                         break;
 209   2          case 5: NRF_CE = 0;                                         break;
 210   2          case 6: Send_SPI_NRF( &COMMAND_CLEAR_IRQ, 2 );              break;
 211   2          case 7: currentProcess = END_PROCESS;                       break;
 212   2          default: break;
 213   2        }
 214   1        return Check_Out();
 215   1      }
 216          
 217          /*NRF get(radio) */
 218          bit NRF_get(/*amount bytes*/){
 219   1        switch(currentProcess){
 220   2          case START_PROCESS: NRF_CE = 1;                               break;
 221   2          case 1: NRF_delay(NRF_DELAY_SHORT);                           break;
 222   2          case 2: /*NRF_CE = 0;*/                                       break;  
 223   2          case 3: Send_SPI_NRF( &COMMAND_READ_RF, /*amount bytes*/ 2 ); break;
 224   2          case 4: Send_SPI_NRF( &COMMAND_CLEAR_FLUSH_RX, 2 );           break;
 225   2          case 5: Send_SPI_NRF( &COMMAND_CLEAR_IRQ, 2 );                break;
 226   2          case 6: currentProcess = END_PROCESS;                         break;
 227   2          default: break;
 228   2        }
 229   1        return Check_Out();
 230   1      } 
 231          
 232          /*send info for SPI*/
 233          void Send_SPI_NRF(unsigned char *message,int amountMessage){
 234   1        int i;
 235   1        for(i = 0; i <= amountMessage; i++){
C51 COMPILER V9.53.0.0   NRF24L01                                                          11/11/2024 11:51:25 PAGE 5   

 236   2          valueBufferArrayTx[i] = *(message + i);
 237   2        }   
 238   1        amountByteArrayForSend = amountMessage;
 239   1        SPI_Start();            //start exchange
 240   1      }
 241          
 242          /* read last answer for spi*/ 
 243          void NRF_read_value(void){
 244   1        int i;
 245   1        for(i = 0; i < NRF_MASSIV_SIZE;i++){
 246   2          readBuf[i] = valueBufferArrayRx[i];
 247   2        }
 248   1      }
 249          
 250          /*check - end process?*/
 251          bit Check_Out(){
 252   1        if(currentProcess == END_PROCESS){ 
 253   2          currentProcess = 0;
 254   2          return 1;
 255   2        }
 256   1        else {
 257   2          currentProcess++;
 258   2          return 0;
 259   2        }
 260   1      }
 261          
 262          /*NRF delay(wait)*/
 263          void NRF_delay(int delayValue){
 264   1        SPI_Delay_Set(delayValue);
 265   1      }
 266          
 267          
 268          
 269            
 270          
 271          
 272          

C51 COMPILATION COMPLETE.  1 WARNING(S),  1 ERROR(S)
