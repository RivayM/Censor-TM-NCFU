C51 COMPILER V9.53.0.0   NRF24L01                                                          10/04/2024 12:31:30 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE NRF24L01
OBJECT MODULE PLACED IN .\Code\Obj\NRF24L01.obj
COMPILER INVOKED BY: D:\USR\Keil_v5\C51\BIN\C51.EXE Code\Source\NRF24L01.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib_nuvoton
                    -;.\Common;.\Code\Head;.\Code\Source;.\Code\Obj;.\LST;.\Output) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\NRF24L
                    -01.lst) TABS(2) OBJECT(.\Code\Obj\NRF24L01.obj)

line level    source

   1          //********************************************************************************************************
             -***
   2          //  NRF24L01 
   3          //********************************************************************************************************
             -***
   4          #include <GPIO.h>
   5          #include <Interface_com.H>
   6          #include <NRF24L01.H>
   7          #include <N76E003.h>
   8          
   9          //**************************************************************************
  10          //  struct for send mode RX
  11          //**************************************************************************
  12          xdata struct NRF_PACKET_SPI packetRX = {
  13            /*reg:            ,value:   */
  14            {W_REG|NRF_CONFIG ,0x03},   //  CONFIG
  15            {W_REG|EN_AA      ,0x00},   //  EN_AA
  16            {W_REG|SETUP_AW   ,0x03},   //  SETUP_AW
  17            {W_REG|RF_CH      ,0x6E},   //  RF_CH   
  18            {W_REG|RF_SETUP   ,0x06},   //  RF_SETUP
  19            {W_REG|EN_RXADDR  ,0x01},   //  EN_RXADDR   
  20            {W_REG|RX_PW_P0   ,0x01},   //  RX_PW_P0
  21            //{0x01,0x02,0x03,0x04,0x05,0x05}               //  RX_PW_P1
  22            {W_REG|TX_ADDR    ,'V','V','V','V','t'},        //  TX_ADDR 
  23            {W_REG|RX_ADDR_P0 ,'V','V','V','V','r'},        //  RX_ADDR0
  24            //{0x01,0x02,0x03,0x04,0x05,0x05}               //  RX_ADDR1
  25            {FLUSH_RX         ,NOP}     //  FLUSH   
  26          };
  27          
  28          //**************************************************************************
  29          //  struct for send mode TX
  30          //**************************************************************************
  31          xdata struct NRF_PACKET_SPI packetTX = {
  32            /*reg:            ,value:*/
  33            {W_REG|NRF_CONFIG ,0x02,0x00,0x04,0x05,0x05},   //  CONFIG
  34            {W_REG|EN_AA      ,0x0B,0x0C,0x0D,0x0E,0x05},   //  EN_AA
  35            {W_REG|SETUP_AW   ,0x02,0x03,0x04,0x05,0x05},   //  SETUP_AW
  36            {W_REG|RF_CH      ,0x02,0x03,0x04,0x05,0x05},   //  RF_CH   
  37            {W_REG|RF_SETUP   ,0x02,0x03,0x04,0x05,0x05},   //  RF_SETUP
  38            {W_REG|EN_RXADDR  ,0x02,0x03,0x04,0x05,0x05},   //  EN_RXADDR   
  39            {W_REG|RX_ADDR_P0 ,0x02,0x03,0x04,0x05,0x05},   //  RX_PW_P0
  40            //{0x01,0x02,0x03,0x04,0x05,0x05}               //  RX_PW_P1
  41            {W_REG|TX_ADDR    ,'V','V','V','V','t'},        //  TX_ADDR 
  42            {W_REG|RX_ADDR_P0 ,'V','V','V','V','r'},        //  RX_ADDR0
  43            //{0x01,0x02,0x03,0x04,0x05,0x05}               //  RX_ADDR1
  44            {FLUSH_RX         ,NOP,0x03,0x04,0x05,0x05}     //  FLUSH   
  45          };
  46          
  47          //**************************************************************************
  48          // NRF24L01
  49          //**************************************************************************
  50          
  51          int currentProgress = 0;
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/04/2024 12:31:30 PAGE 2   

  52          xdata unsigned char readBuf[NRF_MASSIV_SIZE]={0x00}; 
  53          
  54          /*initialization RF*/
  55          bit NRF_init(struct NRF_PACKET_SPI *packet){
  56   1        switch(currentProgress){
  57   2          case START_PROCESS: NRF_CE = 0;                 break;
  58   2          case 1: Timer3_Delay100ms(START_DELAY);         break;
  59   2          case 2: Send_SPI_NRF( packet->vCONFIG,    2 );  break;
  60   2          case 3: Send_SPI_NRF( packet->vEN_AA,     2 );  break;  
  61   2          case 4: Send_SPI_NRF( packet->vSETUP_AW,  2 );  break;  
  62   2          case 5: Send_SPI_NRF( packet->vRF_CH,     2 );  break;  
  63   2          case 6: Send_SPI_NRF( packet->vRF_SETUP,  2 );  break;  
  64   2          case 7: Send_SPI_NRF( packet->vEN_RXADDR, 2 );  break;  
  65   2          case 8: Send_SPI_NRF( packet->vRX_PW_P0,  2 );  break;  
  66   2          case 9: Send_SPI_NRF( packet->vTX_ADDR,   6 );  break;  
  67   2          case 10:Send_SPI_NRF( packet->vRX_ADDR0,  6 );  break;  
  68   2          case 11:NRF_CE = 1;                             break;
  69   2          case 12:currentProgress = END_PROCESS;          break;
  70   2          default: break;
  71   2        }
  72   1        if(currentProgress == END_PROCESS){ 
  73   2          currentProgress = 0;
  74   2          return 1;
  75   2        }
  76   1        else {
  77   2          currentProgress++;
  78   2          return 0;
  79   2        }
  80   1      }
  81          
  82          /*NRF send(radio) */
  83          bit NRF_send(/*struct DATA_PACKET_SEND *packet*/){
  84   1        switch(currentProgress){
  85   2          case START_PROCESS: NRF_CE = 0;                 break;
  86   2          default: break;
  87   2        
  88   2        }
  89   1        //процесс очистки.
  90   1        // дергать сe ( как ардуино гдето 200микросекунд или более)
  91   1        //или попробовать ждать прерывание об окончании отправки пакета
  92   1        // и се= 0
  93   1        if(currentProgress == END_PROCESS){ 
  94   2          currentProgress = 0;
  95   2          return 1;
  96   2        }
  97   1        else {
  98   2          currentProgress++;
  99   2          return 0;
 100   2        }
 101   1      }
 102          
 103          /*NRF get(radio) */
 104          bit NRF_get(/*struct DATA_PACKET_SAVE *packet*/){
 105   1        switch(currentProgress){
 106   2          case START_PROCESS: NRF_CE = 0;       break;
 107   2          case 1: NRF_ack_status();             break; // ждать или прочитать статус
 108   2          case 2: NRF_read_value();             break;
 109   2          case 3: 
 110   2            if( readBuf[0] & FLAG_RX_DR ){
 111   3              Send_SPI_NRF( R_RX_PL,  NRF_MASSIV_SIZE );
 112   3            }
 113   2            else{
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/04/2024 12:31:30 PAGE 3   

 114   3              currentProgress = END_PROCESS;
 115   3            }
 116   2            break;
 117   2          case 4: NRF_read_value();             break;  
 118   2          case 5: 
 119   2            if( NRF_clear_FIFO() ){             // until the process is completed
 120   3              break;
 121   3            }
 122   2            else {
 123   3              return 0;
 124   3            }
 125   2          case 6: currentProgress = END_PROCESS;break;
 126   2          default: break;
 127   2        }
 128   1        if(currentProgress == END_PROCESS){ 
 129   2          currentProgress = 0;
 130   2          return 1;
 131   2        }
 132   1        else {
 133   2          currentProgress++;
 134   2          return 0;
 135   2        }
 136   1      
 137   1      } 
 138          
 139          /*send info for SPI*/
 140          void Send_SPI_NRF(unsigned char *message,int amountMessage){
 141   1        int i;
 142   1        for(i = 0; i <= amountMessage; i++){
 143   2          valueBufferArrayTx[i] = *(message + i);
 144   2        }   
 145   1        amountByteArrayForSend = amountMessage;
 146   1        InCom_SPI_start();            //start exchange
 147   1      }
 148          
 149          /* clear all flags*/    
 150          void NRF_clear_IRQ(void){
 151   1        unsigned char array[NRF_MASSIV_SIZE] = 
 152   1          {W_REG|STATUS,0x70};
 153   1        Send_SPI_NRF(&array,    2);   // Clear RX_DR, TX_DS, MAX_RT flags
 154   1      }
 155          
 156          /* Clear all FIFO*/   
 157          bit NRF_clear_FIFO(void){
 158   1        unsigned char arrayRX[NRF_MASSIV_SIZE] = 
 159   1          {W_REG|FLUSH_RX,NOP};
 160   1        unsigned char arrayTX[NRF_MASSIV_SIZE] = 
 161   1          {W_REG|FLUSH_TX,NOP};
 162   1        switch(currentProgress){
 163   2          case START_PROCESS: NRF_CE = 0;           break;
 164   2          case 1: Send_SPI_NRF(&arrayRX,    2);     break;
 165   2          case 2: Send_SPI_NRF(&arrayTX,    2);     break;
 166   2          case 3: NRF_CE = 1;                       break;  
 167   2          case 4: currentProgress = END_PROCESS;    break;
 168   2          default: break;
 169   2        }
 170   1        if(currentProgress == END_PROCESS){ 
 171   2          currentProgress = 0;
 172   2          return 1;
 173   2        }
 174   1        else {
 175   2          currentProgress++;
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/04/2024 12:31:30 PAGE 4   

 176   2          return 0;
 177   2        }
 178   1      }
 179          
 180          /* ask the status*/ 
 181          void NRF_ack_status(void){
 182   1        unsigned char array[NRF_MASSIV_SIZE] =
 183   1          {STATUS};
 184   1        Send_SPI_NRF( array, 1 );   // read Status
 185   1      } 
 186          
 187          /* read last answer for spi*/ 
 188          void NRF_read_value(void){
 189   1        int i;
 190   1        for(i = 0; i < NRF_MASSIV_SIZE;i++){
 191   2          readBuf[i] = valueBufferArrayRx[i];
 192   2        }
 193   1      }
 194          
 195          
 196          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    689    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =    126    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      32
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
