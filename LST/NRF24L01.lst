C51 COMPILER V9.53.0.0   NRF24L01                                                          10/14/2024 15:32:12 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE NRF24L01
OBJECT MODULE PLACED IN .\Code\Obj\NRF24L01.obj
COMPILER INVOKED BY: D:\USR\Keil_v5\C51\BIN\C51.EXE Code\Source\NRF24L01.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib_nuvoton
                    -;.\Common;.\Code\Head;.\Code\Source;.\Code\Obj;.\LST;.\Output) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\NRF24L
                    -01.lst) TABS(2) OBJECT(.\Code\Obj\NRF24L01.obj)

line level    source

   1          //********************************************************************************************************
             -***
   2          //  NRF24L01 
   3          //********************************************************************************************************
             -***
   4          #include <GPIO.h>
   5          #include <SPI_prog.H>
   6          #include <NRF24L01.H>
   7          #include <N76E003.h>
   8          
   9          //**************************************************************************
  10          /*  struct for send mode RX  */
  11          //**************************************************************************
  12          xdata struct NRF_PACKET_SPI packetRX = {
  13            /*reg:            ,value:   */
  14            {W_REG|NRF_CONFIG ,0x0F},   //  CONFIG
  15            {W_REG|EN_AA      ,0x00},   //  EN_AA
  16            {W_REG|SETUP_AW   ,0x03},   //  SETUP_AW
  17            {W_REG|RF_CH      ,0x6E},   //  RF_CH   
  18            {W_REG|RF_SETUP   ,0x05},   //  RF_SETUP
  19            {W_REG|EN_RXADDR  ,0x1F},   //  EN_RXADDR   
  20            {W_REG|DYNPD      ,0x00},   //  DYNPD
  21            {W_REG|FEATURE    ,0x00},   //  FEATURE
  22            
  23            {W_REG|RX_PW_P0   ,0x01},   //  RX_PW_P0
  24            {W_REG|RX_PW_P1   ,0x01},   //  RX_PW_P0
  25            {W_REG|RX_PW_P2   ,0x01},   //  RX_PW_P0
  26            {W_REG|RX_PW_P3   ,0x01},   //  RX_PW_P0
  27            {W_REG|RX_PW_P4   ,0x01},   //  RX_PW_P0
  28            {W_REG|RX_PW_P5   ,0x01},   //  RX_PW_P0
  29            //adr write lsbyte first
  30            {W_REG|TX_ADDR    ,'X','X','X','X','X'},  //  TX_ADDR 
  31            
  32            {W_REG|RX_ADDR_P0 ,'X','X','X','X','X'},  //  RX_ADDR0
  33            {W_REG|RX_ADDR_P1 ,'V','V','V','V','V'},  //  RX_ADDR0
  34            {W_REG|RX_ADDR_P2 ,'q'},                  //  RX_ADDR0
  35            {W_REG|RX_ADDR_P3 ,'w'},                  //  RX_ADDR0
  36            {W_REG|RX_ADDR_P4 ,'e'},                  //  RX_ADDR0
  37            {W_REG|RX_ADDR_P5 ,'i'},                  //  RX_ADDR0
  38            
  39            {FLUSH_RX         ,NOP}     //  FLUSH   
  40          };
  41          //**************************************************************************
  42          /*  struct for send mode TX  */
  43          //**************************************************************************
  44          xdata struct NRF_PACKET_SPI packetTX = {
  45            /*reg:            ,value:   */
  46            {W_REG|NRF_CONFIG ,0x0E},   //  CONFIG
  47          };
  48          //**************************************************************************
  49          /*  struct for READ state reg  */
  50          //**************************************************************************
  51          xdata struct NRF_PACKET_SPI packetRX_READ = {
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/14/2024 15:32:12 PAGE 2   

  52            /*reg:            ,value:   */
  53            {R_REG|NRF_CONFIG },    //  CONFIG
  54            {R_REG|EN_AA      },    //  EN_AA
  55            {R_REG|SETUP_AW   },    //  SETUP_AW
  56            {R_REG|RF_CH      },    //  RF_CH   
  57            {R_REG|RF_SETUP   },    //  RF_SETUP
  58            {R_REG|EN_RXADDR  },    //  EN_RXADDR   
  59            {R_REG|DYNPD      },    //  DYNPD
  60            {R_REG|FEATURE    },    //  FEATURE
  61            
  62            {R_REG|RX_PW_P0   },    //  RX_PW_P0
  63            {R_REG|RX_PW_P1   },    //  RX_PW_P0
  64            {R_REG|RX_PW_P2   },    //  RX_PW_P0
  65            {R_REG|RX_PW_P3   },    //  RX_PW_P0
  66            {R_REG|RX_PW_P4   },    //  RX_PW_P0
  67            {R_REG|RX_PW_P5   },    //  RX_PW_P0
  68            {R_REG|TX_ADDR    },    //  TX_ADDR 
  69            
  70            {R_REG|RX_ADDR_P0 },    //  RX_ADDR0
  71            {R_REG|RX_ADDR_P1 },    //  RX_ADDR0
  72            {R_REG|RX_ADDR_P2 },    //  RX_ADDR0
  73            {R_REG|RX_ADDR_P3 },    //  RX_ADDR0
  74            {R_REG|RX_ADDR_P4 },    //  RX_ADDR0
  75            {R_REG|RX_ADDR_P5 },    //  RX_ADDR0
  76            
  77            {FLUSH_RX         }     //  FLUSH   
  78          };
  79          
  80          //**************************************************************************
  81          // ARRAY
  82          //**************************************************************************
  83          xdata unsigned char COMMAND_SEND_RF       [NRF_MASSIV_SIZE] = 
  84              {W_TX_PL /*next byte for data send[1-x]*/};
  85          xdata unsigned char COMMAND_READ_RF       [NRF_MASSIV_SIZE] = 
  86              {R_RX_PL};
  87          xdata unsigned char COMMAND_CLEAR_FLUSH_RX[NRF_MASSIV_SIZE] = 
  88              {FLUSH_RX};
  89          xdata unsigned char COMMAND_CLEAR_FLUSH_TX[NRF_MASSIV_SIZE] = 
  90              {FLUSH_TX};
  91          xdata unsigned char COMMAND_CLEAR_IRQ     [NRF_MASSIV_SIZE] = 
  92              {W_REG|STATUS,0x70};
  93          xdata unsigned char COMMAND_READ_PIPE0    [NRF_MASSIV_SIZE] = 
  94              {RX_PW_P0};     
  95          xdata unsigned char COMMAND_READ_FIFO_STAT[NRF_MASSIV_SIZE] = 
  96              {FIFO_STATUS};    
  97          xdata unsigned char COMMAND_W_ACK_PAYLOAD [NRF_MASSIV_SIZE] = 
  98              {W_ACK_PL + /*need get(in status) ->PPP*/ 0x00};  
  99              
 100          //**************************************************************************
 101          /* NRF24L01 additional        */
 102          //**************************************************************************
 103          xdata unsigned char readBuf[NRF_MASSIV_SIZE]={0x00}; 
 104          
 105          bit FlagDataReadReady = 0;
 106          int currentProcess = 0;
 107              
 108          /*initialization RF*/
 109          bit NRF_init(struct NRF_PACKET_SPI *packet){
 110   1        switch(currentProcess){
 111   2          case START_PROCESS: NRF_CE = 0;                 break;
 112   2          
 113   2          case 1: /*Send_SPI_NRF( packet->vCONFIG,    2 );*/  break;
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/14/2024 15:32:12 PAGE 3   

 114   2          case 2: NRF_delay();                            break;
 115   2          case 3: Send_SPI_NRF( packet->vEN_AA,     2 );  break;
 116   2          case 4: Send_SPI_NRF( packet->vSETUP_AW,  2 );  break;  
 117   2          case 5: Send_SPI_NRF( packet->vRF_CH,     2 );  break;  
 118   2          case 6: Send_SPI_NRF( packet->vRF_SETUP,  2 );  break;  
 119   2          case 7: Send_SPI_NRF( packet->vEN_RXADDR, 2 );  break;
 120   2          case 8: Send_SPI_NRF( packet->vDYNPD,     2 );  break;  
 121   2          case 9: Send_SPI_NRF( packet->vFEATURE,   2 );  break;
 122   2          
 123   2          case 10:Send_SPI_NRF( packet->vTX_ADDR,   6 );  break;
 124   2      
 125   2          case 11:Send_SPI_NRF( packet->vRX_PW_P0,  2 );  break;
 126   2          case 12:Send_SPI_NRF( packet->vRX_PW_P1,  2 );  break;
 127   2          case 13:Send_SPI_NRF( packet->vRX_PW_P2,  2 );  break;
 128   2          case 14:Send_SPI_NRF( packet->vRX_PW_P3,  2 );  break;
 129   2          case 15:Send_SPI_NRF( packet->vRX_PW_P4,  2 );  break;
 130   2          case 16:Send_SPI_NRF( packet->vRX_PW_P5,  2 );  break;
 131   2          
 132   2          case 17:Send_SPI_NRF( packet->vRX_ADDR0,  6 );  break;
 133   2          case 18:Send_SPI_NRF( packet->vRX_ADDR1,  6 );  break;
 134   2          case 19:Send_SPI_NRF( packet->vRX_ADDR2,  2 );  break;
 135   2          case 20:Send_SPI_NRF( packet->vRX_ADDR3,  2 );  break;
 136   2          case 21:Send_SPI_NRF( packet->vRX_ADDR4,  2 );  break;
 137   2          case 22:Send_SPI_NRF( packet->vRX_ADDR5,  2 );  break;
 138   2          case 23:Send_SPI_NRF( packet->vCONFIG,    2 );  break;
 139   2          case 24: NRF_delay();                           break;
 140   2          
 141   2          case 25:NRF_CE = 1;                             break;
 142   2          case 26:currentProcess = END_PROCESS;           break;
 143   2          default: break;
 144   2        }
 145   1        return Check_Out();
 146   1      }
 147          
 148          /*NRF change mode to RX or TX */
 149          bit NRF_change_mode_RF(struct NRF_PACKET_SPI *packet, bit stateCeEnd){
 150   1        switch(currentProcess){
 151   2          case START_PROCESS: NRF_CE = 0;                 break;
 152   2          case 1: NRF_delay();                            break;
 153   2          case 2: Send_SPI_NRF( packet->vCONFIG,      2 );break;
 154   2          case 3: NRF_delay();                            break;
 155   2          case 4: NRF_CE = stateCeEnd;                    break;
 156   2          case 5: currentProcess = END_PROCESS;           break;
 157   2          default: break;
 158   2        }
 159   1        return Check_Out();
 160   1      }
 161          
 162          /*NRF send(radio) */
 163          bit NRF_send(/*struct DATA_PACKET_SEND *packet*/){
 164   1        switch(currentProcess){
 165   2          case START_PROCESS: NRF_CE = 0;               break;
 166   2          case 1: COMMAND_SEND_RF[1]++;                 break;    
 167   2          case 2: Send_SPI_NRF( &COMMAND_SEND_RF, 2 );  break;
 168   2          case 5: NRF_CE = 1;                           break;
 169   2          case 6: NRF_delay();NRF_delay();NRF_delay();  break;
 170   2          case 7: NRF_CE = 0;                           break;
 171   2          case 8: Send_SPI_NRF( &COMMAND_CLEAR_IRQ, 2 );break;
 172   2          case 9: currentProcess = END_PROCESS;         break;
 173   2          default: break;
 174   2        }
 175   1        return Check_Out();
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/14/2024 15:32:12 PAGE 4   

 176   1      }
 177          
 178          /*NRF get(radio) */
 179          bit NRF_get(/*struct DATA_PACKET_SAVE *packet*/){
 180   1        switch(currentProcess){
 181   2          case START_PROCESS: /*NRF_CE = 1;*/         break;
 182   2          case 1: NRF_CE = 1;                         break;
 183   2          case 2: NRF_delay();NRF_delay();NRF_delay();break;
 184   2          case 3: /*NRF_CE = 0;*/                     break;  
 185   2          case 4: 
 186   2            Send_SPI_NRF( &COMMAND_READ_RF, 2 );
 187   2            break;
 188   2          case 7: 
 189   2            Send_SPI_NRF( &COMMAND_CLEAR_FLUSH_RX, 2 );
 190   2            break;
 191   2          case 8: 
 192   2            Send_SPI_NRF( &COMMAND_CLEAR_IRQ, 2 );
 193   2            break;
 194   2          case 9: currentProcess = END_PROCESS;break;
 195   2          default: break;
 196   2        }
 197   1        return Check_Out();
 198   1      } 
 199          
 200          /*send info for SPI*/
 201          void Send_SPI_NRF(unsigned char *message,int amountMessage){
 202   1        int i;
 203   1        for(i = 0; i <= amountMessage; i++){
 204   2          valueBufferArrayTx[i] = *(message + i);
 205   2        }   
 206   1        amountByteArrayForSend = amountMessage;
 207   1        SPI_Start();            //start exchange
 208   1      }
 209          
 210          /* clear all flags*/    
 211          void NRF_clear_IRQ(void){
 212   1        Send_SPI_NRF(&COMMAND_CLEAR_IRQ,    2);   // Clear RX_DR, TX_DS, MAX_RT flags
 213   1      }
 214          
 215          /* ask the status*/ 
 216          void NRF_ack_status(void){
 217   1        unsigned char array[NRF_MASSIV_SIZE] =
 218   1          {STATUS};
 219   1        Send_SPI_NRF( array, 1 );   // read Status
 220   1      } 
 221          
 222          /* read last answer for spi*/ 
 223          void NRF_read_value(void){
 224   1        int i;
 225   1        for(i = 0; i < NRF_MASSIV_SIZE;i++){
 226   2          readBuf[i] = valueBufferArrayRx[i];
 227   2          //valueBufferArrayRx[i] = 0x00;         // forced zeroing
 228   2        }
 229   1      }
 230          
 231          /*check - end process?*/
 232          bit Check_Out(){
 233   1        if(currentProcess == END_PROCESS){ 
 234   2          currentProcess = 0;
 235   2          return 1;
 236   2        }
 237   1        else {
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/14/2024 15:32:12 PAGE 5   

 238   2          currentProcess++;
 239   2          return 0;
 240   2        }
 241   1      }
 242          
 243          /*NRF delay(wait)*/
 244          void NRF_delay(void){
 245   1        SPI_Delay_Set(DELAY);
 246   1      }
 247          
 248          
 249          
 250            
 251          
 252          
 253          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    782    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =    450    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
