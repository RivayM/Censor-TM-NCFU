C51 COMPILER V9.53.0.0   NRF24L01                                                          10/07/2024 15:07:21 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE NRF24L01
OBJECT MODULE PLACED IN .\Code\Obj\NRF24L01.obj
COMPILER INVOKED BY: D:\USR\Keil_v5\C51\BIN\C51.EXE Code\Source\NRF24L01.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib_nuvoton
                    -;.\Common;.\Code\Head;.\Code\Source;.\Code\Obj;.\LST;.\Output) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\NRF24L
                    -01.lst) TABS(2) OBJECT(.\Code\Obj\NRF24L01.obj)

line level    source

   1          //********************************************************************************************************
             -***
   2          //  NRF24L01 
   3          //********************************************************************************************************
             -***
   4          #include <GPIO.h>
   5          #include <Interface_com.H>
   6          #include <NRF24L01.H>
   7          #include <N76E003.h>
   8          
   9          //**************************************************************************
  10          //  struct for send mode RX
  11          //**************************************************************************
  12          xdata struct NRF_PACKET_SPI packetRX = {
  13            /*reg:            ,value:   */
  14            {W_REG|NRF_CONFIG ,0x0F},   //  CONFIG
  15            {W_REG|EN_AA      ,0x3f},   //  EN_AA
  16            {W_REG|SETUP_AW   ,0x03},   //  SETUP_AW
  17            {W_REG|RF_CH      ,0x4C},   //  RF_CH   
  18            {W_REG|RF_SETUP   ,0x07},   //  RF_SETUP
  19            {W_REG|EN_RXADDR  ,0x02},   //  EN_RXADDR   
  20            {W_REG|DYNPD      ,0x03},   //  DYNPD
  21            {W_REG|FEATURE    ,0x06},   //  FEATURE
  22            
  23            {W_REG|RX_PW_P0   ,0x01},   //  RX_PW_P0
  24            {W_REG|RX_PW_P1   ,0x01},   //  RX_PW_P0
  25            {W_REG|RX_PW_P2   ,0x01},   //  RX_PW_P0
  26            {W_REG|RX_PW_P3   ,0x01},   //  RX_PW_P0
  27            {W_REG|RX_PW_P4   ,0x01},   //  RX_PW_P0
  28            {W_REG|RX_PW_P5   ,0x01},   //  RX_PW_P0
  29            
  30            {W_REG|TX_ADDR    ,'X','X','X','X','O'},  //  TX_ADDR 
  31            
  32            {W_REG|RX_ADDR_P0 ,'X','X','X','X','O'},  //  RX_ADDR0
  33            {W_REG|RX_ADDR_P1 ,'V','V','V','V','r'},  //  RX_ADDR0
  34            {W_REG|RX_ADDR_P2 ,'q'},                  //  RX_ADDR0
  35            {W_REG|RX_ADDR_P3 ,'w'},                  //  RX_ADDR0
  36            {W_REG|RX_ADDR_P4 ,'e'},                  //  RX_ADDR0
  37            {W_REG|RX_ADDR_P5 ,'i'},                  //  RX_ADDR0
  38            
  39            {FLUSH_RX         ,NOP}     //  FLUSH   
  40          };
  41          
  42          //**************************************************************************
  43          //  struct for send mode TX
  44          //**************************************************************************
  45          xdata struct NRF_PACKET_SPI packetTX;
  46          
  47          //**************************************************************************
  48          // NRF24L01
  49          //**************************************************************************
  50          
  51          bit FlagDataReadReady;
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/07/2024 15:07:21 PAGE 2   

  52          int currentProcess = 0;
  53          //**************************************************************************
  54          // ARRAY
  55          //**************************************************************************
  56          
  57          xdata unsigned char readBuf[NRF_MASSIV_SIZE]={0x00}; 
  58          xdata unsigned char COMMAND_READ_RF[NRF_MASSIV_SIZE] = 
  59              {R_RX_PL, NRF_MASSIV_SIZE};
  60          xdata unsigned char COMMAND_CLEAR_FLUSH_RX[NRF_MASSIV_SIZE] = 
  61              {W_REG|FLUSH_RX,NOP};
  62          xdata unsigned char COMMAND_CLEAR_FLUSH_TX[NRF_MASSIV_SIZE] = 
  63              {W_REG|FLUSH_TX,NOP};
  64          xdata unsigned char COMMAND_CLEAR_IRQ[NRF_MASSIV_SIZE] = 
  65              {W_REG|STATUS,0x70};
  66              
  67          /*initialization RF*/
  68          bit NRF_init(struct NRF_PACKET_SPI *packet){
  69   1        switch(currentProcess){
  70   2          case START_PROCESS: NRF_CE = 0;                 break;
  71   2          
  72   2          case 1: Timer3_Delay100ms(START_DELAY);         break;
  73   2          case 2: Send_SPI_NRF( packet->vCONFIG,    2 );  break;
  74   2          case 3: Send_SPI_NRF( packet->vEN_AA,     2 );  break;  
  75   2          case 4: Send_SPI_NRF( packet->vSETUP_AW,  2 );  break;  
  76   2          case 5: Send_SPI_NRF( packet->vRF_CH,     2 );  break;  
  77   2          case 6: Send_SPI_NRF( packet->vRF_SETUP,  2 );  break;  
  78   2          case 7: Send_SPI_NRF( packet->vEN_RXADDR, 2 );  break;  
  79   2          case 8: Send_SPI_NRF( packet->vTX_ADDR,   6 );  break;
  80   2          
  81   2          case 9: Send_SPI_NRF( packet->vRX_PW_P0,  2 );  break;
  82   2          case 10:Send_SPI_NRF( packet->vRX_PW_P1,  2 );  break;
  83   2          case 11:Send_SPI_NRF( packet->vRX_PW_P2,  2 );  break;
  84   2          case 12:Send_SPI_NRF( packet->vRX_PW_P3,  2 );  break;
  85   2          case 13:Send_SPI_NRF( packet->vRX_PW_P4,  2 );  break;
  86   2          case 14:Send_SPI_NRF( packet->vRX_PW_P5,  2 );  break;
  87   2          
  88   2          case 15:Send_SPI_NRF( packet->vRX_ADDR0,  6 );  break;
  89   2          case 16:Send_SPI_NRF( packet->vRX_ADDR1,  6 );  break;
  90   2          case 17:Send_SPI_NRF( packet->vRX_ADDR2,  2 );  break;
  91   2          case 18:Send_SPI_NRF( packet->vRX_ADDR3,  2 );  break;
  92   2          case 19:Send_SPI_NRF( packet->vRX_ADDR4,  2 );  break;
  93   2          case 20:Send_SPI_NRF( packet->vRX_ADDR5,  2 );  break;
  94   2          
  95   2          case 21:NRF_CE = 1;                             break;
  96   2          case 22:currentProcess = END_PROCESS;           break;
  97   2          default: break;
  98   2        }
  99   1        return Check_Out();
 100   1      }
 101          
 102          /*NRF send(radio) */
 103          bit NRF_send(/*struct DATA_PACKET_SEND *packet*/){
 104   1        switch(currentProcess){
 105   2          case START_PROCESS: NRF_CE = 0;                 break;
 106   2          default: break;
 107   2        
 108   2        }
 109   1        //процесс очистки.
 110   1        // дергать сe ( как ардуино гдето 200микросекунд или более)
 111   1        //или попробовать ждать прерывание об окончании отправки пакета
 112   1        // и се= 0
 113   1        return Check_Out();
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/07/2024 15:07:21 PAGE 3   

 114   1      }
 115          
 116          /*NRF get(radio) */
 117          bit NRF_get(/*struct DATA_PACKET_SAVE *packet*/){
 118   1        switch(currentProcess){
 119   2          case START_PROCESS: NRF_CE = 0;       break;
 120   2          case 1: NRF_ack_status();             break; // ждать или прочитать статус
 121   2          case 2: NRF_read_value();             break;
 122   2          case 3: 
 123   2            if(FlagDataReadReady){Send_SPI_NRF( &COMMAND_READ_RF,   2 );}
 124   2            else {return 0;}
 125   2            break;
 126   2          case 4: NRF_read_value();             break;  
 127   2          case 5: Send_SPI_NRF( &COMMAND_CLEAR_FLUSH_RX,  2 );break;      
 128   2          case 6: Send_SPI_NRF( &COMMAND_CLEAR_IRQ,   2 );    break;
 129   2          case 7: NRF_CE = 1;                   break;
 130   2          case 8: currentProcess = END_PROCESS; break;
 131   2          case 9: FlagDataReadReady = 0;        break;
 132   2          default: break;
 133   2        }
 134   1        return Check_Out();
 135   1      } 
 136          
 137          /*send info for SPI*/
 138          void Send_SPI_NRF(unsigned char *message,int amountMessage){
 139   1        int i;
 140   1        for(i = 0; i <= amountMessage; i++){
 141   2          valueBufferArrayTx[i] = *(message + i);
 142   2        }   
 143   1        amountByteArrayForSend = amountMessage;
 144   1        InCom_SPI_start();            //start exchange
 145   1      }
 146          
 147          /* clear all flags*/    
 148          void NRF_clear_IRQ(void){
 149   1        Send_SPI_NRF(&COMMAND_CLEAR_IRQ,    2);   // Clear RX_DR, TX_DS, MAX_RT flags
 150   1      }
 151          
 152          /* ask the status*/ 
 153          void NRF_ack_status(void){
 154   1        unsigned char array[NRF_MASSIV_SIZE] =
 155   1          {STATUS};
 156   1        Send_SPI_NRF( array, 1 );   // read Status
 157   1      } 
 158          
 159          /* read last answer for spi*/ 
 160          void NRF_read_value(void){
 161   1        int i;
 162   1        for(i = 0; i < NRF_MASSIV_SIZE;i++){
 163   2          readBuf[i] = valueBufferArrayRx[i];
 164   2        }
 165   1      }
 166          
 167          /*check - end process?*/
 168          bit Check_Out(){
 169   1        if(currentProcess == END_PROCESS){ 
 170   2          currentProcess = 0;
 171   2          return 1;
 172   2        }
 173   1        else {
 174   2          currentProcess++;
 175   2          return 0;
C51 COMPILER V9.53.0.0   NRF24L01                                                          10/07/2024 15:07:21 PAGE 4   

 176   2        }
 177   1      }
 178          
 179          
 180          
 181          
 182            
 183          
 184          
 185          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    685    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =    294    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
