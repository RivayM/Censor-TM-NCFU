C51 COMPILER V9.53.0.0   SPI_PROG                                                          11/19/2024 15:08:59 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE SPI_PROG
OBJECT MODULE PLACED IN .\Code\Obj\SPI_prog.obj
COMPILER INVOKED BY: D:\USR\Keil_v5\C51\BIN\C51.EXE Code\Source\SPI_prog.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Lib_nuvoton
                    -;.\Common;.\Code\Head;.\Code\Source;.\Code\Obj;.\LST;.\Output) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\SPI_pr
                    -og.lst) TABS(2) OBJECT(.\Code\Obj\SPI_prog.obj)

line level    source

   1          //********************************************************
   2          //  PROG_SPI 
   3          //********************************************************
   4          #include <SPI_prog.H>
   5          #include <N76E003.H>
   6          
   7          unsigned char valueBufferArrayTx[BUFFER_SPI_MASSIV_SIZE]; 
   8          unsigned char valueBufferArrayRx[BUFFER_SPI_MASSIV_SIZE];  
   9          
  10          int amountByteArrayForSend  = BUFFER_SPI_MASSIV_SIZE; 
  11          int counterBit              = 0;   
  12          int counterByte             = 0;
  13          
  14          bit FlagSPIGlobal           = 0;
  15          bit FlagExchangeSPIStart    = 0;
  16          
  17          int valueDelay              = 0;
  18          bit FlagSPIDelay            = 0;
  19          
  20          void SPI_write_amount_byte(int value){amountByteArrayForSend = value;}
  21          
  22          unsigned char *SPI_get_RX_buf(){return &valueBufferArrayRx;}
  23          
  24          void SPI_write_TX_buf(unsigned char *buf){
  25   1        int  i;
  26   1        for( i = 0; i <= amountByteArrayForSend; i++ ){
  27   2          valueBufferArrayTx[i] = *( buf + i );
  28   2        }
  29   1      }
  30          
  31          
  32          //********************************************************
  33          //      _____      _____        ->  CLK
  34          //      |   |      |   |
  35          //______|   |______|   |______
  36          //  f()  f()  f()   f()  f()    ->  SPI_exchange_start()
  37          //********************************************************
  38          /* main func(for timer) */
  39          void SPI_exchange_start(void){
  40   1        /*every clk launch*/
  41   1        SPI_exchange_do( 
  42   1          SPI_Data_Convert_Bit(
  43   1            &valueBufferArrayTx[counterByte]),  // buf  for TX
  44   1          &valueBufferArrayRx[counterByte]);    // buf  for RX
  45   1      }
  46          
  47          /* exchange bitwise operation */
  48          void SPI_exchange_do(unsigned char valueMosi, unsigned char *outSideBuffer){ 
  49   1        if( counterBit || SPI_CPOL ) {        // CPOL - when start clk
  50   2          PIN_CLK_SPI =~ PIN_CLK_SPI;         // clocking
  51   2        }     
  52   1        if( PIN_CLK_SPI == SPI_CPHA) {        // CPHA - when next bit
  53   2      /******************************/
C51 COMPILER V9.53.0.0   SPI_PROG                                                          11/19/2024 15:08:59 PAGE 2   

  54   2          switch(counterBit){                 // Start
  55   3      /*End bit packet  */
  56   3            case BUFFER_SPI /*  max bit */:                 
  57   3              PIN_MOSI_SPI = 1;
  58   3              //PIN_MISO_SPI = 1;
  59   3              PIN_CLK_SPI  = SPI_CPOL;  
  60   3              counterBit   = 0;
  61   3              SPI_exchange_end();             // continue?
  62   3              SPI_Data_Convert_Byte();        // next packet
  63   3              break;
  64   3      /* process going  */
  65   3            default  /* 0 -> max bit - 1*/: 
  66   3              PIN_CS_SPI   = 0;
  67   3      /* send MoSi  */
  68   3              if(valueMosi){PIN_MOSI_SPI = 1;}
  69   3              else{         PIN_MOSI_SPI = 0;}
  70   3      /* send MiSo  */
  71   3              if ( PIN_MISO_SPI == 1){          
  72   4                outSideBuffer = outSideBuffer +
  73   4                SPI_Data_Convert_Bit(outSideBuffer);
  74   4              } 
  75   3      /* next bit   */
  76   3              counterBit++;                   
  77   3              break;
  78   3          }
  79   2        }
  80   1      /******************************/  
  81   1      }
  82          
  83          /* In the latest BYTE exchange SPI*/
  84          void SPI_exchange_end(void){  
  85   1        #if SPI_DATA_BYTE == SPI_MS_BYTE
                  if(counterByte == 0){ 
                    SPI_End();  
                  }
                #else
  90   1          if(counterByte == amountByteArrayForSend - 1){ 
  91   2            SPI_End();  
  92   2          }
  93   1        #endif
  94   1      }
  95          
  96          /* In the end exchange SPI*/
  97          void SPI_End(void){
  98   1        PIN_CS_SPI  = 1;
  99   1        FlagSPIGlobal = 0; 
 100   1      }
 101          
 102          
 103          /* Convert DATA BYTE*/
 104          void SPI_Data_Convert_Byte(){ 
 105   1      #if SPI_DATA_BYTE == SPI_MS_BYTE
                counterByte--;     // SPI_MSbyte 
              #else
 108   1        counterByte++;     // SPI_LSbyte
 109   1      #endif
 110   1      }
 111          
 112          /*Convert DATA BIT*/
 113          unsigned char SPI_Data_Convert_Bit(unsigned char *outSideBuffer){
 114   1        unsigned char buf;
 115   1        buf = *outSideBuffer;  
C51 COMPILER V9.53.0.0   SPI_PROG                                                          11/19/2024 15:08:59 PAGE 3   

 116   1        /*
 117   1        in Nuvaton, shift operations by 0, we go to -1 
 118   1        and force the register to go around in a circle 
 119   1        (the whole cycle) - long operation
 120   1        */
 121   1      #if SPI_DATA_BIT == SPI_MSB
 122   1        if(counterBit >= BUFFER_SPI - 1){ 
 123   2          buf = buf & 0x01; 
 124   2        }
 125   1        else {
 126   2          buf = buf & 0x01 << (BUFFER_SPI - counterBit - 1);// SPI_MSB
 127   2        }
 128   1      #else
                if(counterBit >= BUFFER_SPI - 1){
                  buf = buf & 0x01 << BUFFER_SPI - 1;
                }
                else{
                  buf = buf & 0x01 << counterBit;                   // SPI_LSB
                }
              #endif
 136   1        return buf;
 137   1      }
 138          
 139          /*Delay = 1 timer cycle timer*/
 140          void SPI_Delay(){
 141   1        if(valueDelay){ 
 142   2          valueDelay--; 
 143   2        }
 144   1        else{ 
 145   2          FlagSPIDelay = 0; 
 146   2          FlagSPIGlobal = 0;
 147   2        }
 148   1      }
 149          
 150          /*SET Delay = 1 timer cycle timer*/
 151          void SPI_Delay_Set(int delay){
 152   1        valueDelay = delay;
 153   1        FlagSPIDelay = 1;
 154   1        FlagSPIGlobal = 1;
 155   1      }
 156          
 157          /* init clk */
 158          void SPI_CLK_init(bit value){ 
 159   1        PIN_CLK_SPI = value;
 160   1      }
 161          
 162          /* Start exchange spi */
 163          void SPI_Start(void){
 164   1      #if SPI_DATA_BYTE == SPI_MS_BYTE
                counterByte = amountByteArrayForSend -1;
              #else
 167   1        counterByte = 0;
 168   1      #endif
 169   1        FlagSPIGlobal = 1;
 170   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    293    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   SPI_PROG                                                          11/19/2024 15:08:59 PAGE 4   

   DATA SIZE        =     20       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
